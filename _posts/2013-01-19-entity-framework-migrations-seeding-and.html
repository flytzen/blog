---
layout: post
title: Entity Framework Migrations, seeding and server farms
date: '2013-01-19T16:19:00.000Z'
author: Frans Lytzen
tags: 
modified_time: '2015-11-12T17:44:08.057Z'
blogger_id: tag:blogger.com,1999:blog-8302357413081836531.post-624353361821512613
blogger_orig_url: http://blog.lytzen.name/2013/01/entity-framework-migrations-seeding-and.html
---

Entity Framework Migrations offers a way to evolve your database schema over time. The schema is fine, but what about your actual data? You may have configuration settings in the database and how do you handle it when you need to add a new configuration setting?<br />With Entity Framework Migrations enabled, your seeder function will run every time you restart your application, so as long as your new configuration setting is in your seeder all will be well. Well, sort of... How do you avoid adding a duplicate row the next time your application is restarted? A simple answer with Code First would be something like;<br /><br /><div class="wlWriterEditableSmartContent" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:6bdf356e-9e4c-48fd-b8a9-3987896b283c" style="display: inline; float: none; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;"><pre class="prettyprint">if (!context.Entries.Any(e =&gt; e.Value.Equals(value)))<br />{<br />    var entry = new Entry() { // initialize };<br />    context.Entries.Add(entry);<br />    context.SaveChanges();<br />}</pre></div><br /><br />That works well until you have more than one server as you may then have two or more servers running this code at the same time.<br />Personally I happen to use Azure so I always have at least two servers.<br /><br />In Entity Framework 5 you have the AddOrUpdate extension method but you may not always want to <i>update&nbsp;</i>stuff - sometimes you may want to insert it if it doesn't exist and otherwise leave it alone. Or you may be using EF4.<br /><br />The key to handling this is to obtain a table lock before you check and insert. Now, table locks are normally very bad things because it stops other users from reading from the table – which is of course what you want in this scenario – but you do need to carefully consider any adverse effect this may have on your application. <a href="https://twitter.com/tpeplow">Tom Peplow</a> has a a very good <a href="http://peplowdown.wordpress.com/2010/07/18/locking-across-servers-table-locks-with-entity-framework/">article</a> on how to achieve table locks with Entity Frameworks. I have adapted his approach for use specifically when seeding with Code First.<br /><br />For the examples below, I am imagining an entity called “Entry” and the underlying database table is called “Entries”. Entry has a “Value” property which is the one I want to be unique in my example, but just replace the lambdas as required for your needs.<br /><br />The code below will obtain a table lock before checking and inserting;<br /><br /><div class="wlWriterEditableSmartContent" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:c58d6d4d-fe87-4f48-8aa1-5a8400cd5ee8" style="display: inline; float: none; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;"><pre class="prettyprint">using (var scope = new TransactionScope(<br />        TransactionScopeOption.Required,&nbsp;<br />        new TransactionOptions()&nbsp;<br />            { IsolationLevel = IsolationLevel.ReadCommitted })                            )<br />    {<br />    context.Database.ExecuteSqlCommand(<br />        "select 1 from Entries with (tablockx, holdlock) where 0 = 1");<br />    if (!context.Entries.Any(e =&gt; e.Value.Equals(value)))<br />    {<br />        var entry = new Entry() { // Initialize };<br />        context.Entries.Add(entry);<br />        context.SaveChanges();<br />    }<br />    <br />    scope.Complete();<br />}</pre></div><br /><br />If you find yourself needing to do this a lot, you could create an extension method like this, which can work for any entity and table;<br /><br /><div class="wlWriterEditableSmartContent" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:0f4aa2d3-e3bc-4def-851e-3bf95357741b" style="display: inline; float: none; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;"><pre class="prettyprint">public static class DbContextExtensions<br />{<br />    public static bool UniqueInsert&lt;TContext, TEntity&gt;(<br />        this TContext context,&nbsp;<br />        Func&lt;TContext, IDbSet&lt;TEntity&gt;&gt; dbSetAccessor,&nbsp;<br />        TEntity entity,&nbsp;<br />        Func&lt;TEntity,bool&gt; areSame,&nbsp;<br />        string underlyingTableName)&nbsp;<br />        where TContext : DbContext&nbsp;<br />        where TEntity : class<br />    {<br />        using (var scope = new TransactionScope(<br />                  TransactionScopeOption.Required,&nbsp;<br />                  new TransactionOptions()&nbsp;<br />                     { IsolationLevel = IsolationLevel.ReadCommitted }))<br />        {<br />            try<br />            {<br />                context.Database.ExecuteSqlCommand(<br />                    String.Format("select 1 from {0} with (tablockx, holdlock) where 0 = 1",&nbsp;<br />                    underlyingTableName));<br />                var set = dbSetAccessor(context);<br />                if (!set.Any(areSame))<br />                {<br />                    set.Add(entity);<br />                    context.SaveChanges();<br />                    return true;<br />                }<br />                return false;<br />            }<br />            finally<br />            {<br />                scope.Complete();                    <br />            }<br />        }<br />    }<br />}</pre></div><br />And call it like this:<br /><br /><div class="wlWriterEditableSmartContent" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:a53f661e-9377-40ae-b4e8-2b9c4264c7bd" style="display: inline; float: none; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;"><pre class="prettyprint">var entry = new Entry() { // initialize };<br />context.UniqueInsert(<br />    c =&gt; c.Entries,&nbsp;<br />    entry ,&nbsp;<br />    dbEntity =&gt; dbEntity.Value.Equals(entry.Value),&nbsp;<br />    "Entries");</pre></div>