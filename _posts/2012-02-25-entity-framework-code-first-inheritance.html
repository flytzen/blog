---
layout: post
title: Entity Framework Code First, Inheritance and ComplexType
date: '2012-02-25T15:00:00.001Z'
author: Frans Lytzen
tags: 
modified_time: '2015-11-12T17:19:17.497Z'
blogger_id: tag:blogger.com,1999:blog-8302357413081836531.post-2052946920699370349
blogger_orig_url: http://blog.lytzen.name/2012/02/entity-framework-code-first-inheritance.html
---

In one of the applications we are working on, we have a pretty complex inheritance hierarchy which is mapped to SQL Server using Entity Framework 4.3 using Code First. We noticed that when selecting from the base type just on ID we had terrible performance. Some investigation revealed that the simple select-by-ID generated a SQL Statement that was 360,000 characters long. Generating the SQL statement took 1.5s, causing serious performance issues. Quite a lot of investigation revealed that Code First and Complex Types really don’t play well together. It is entirely possible to place a single property on a single class and massively decrease performance of your solution without it being at all obvious what is happening.<br />I don’t think this is necessarily a fault with Entity Framework nor do I pretend to fully understand what is happening, but here is a walk through that will show the issue. Note, for background reference on inheritance handling in EF Code First, I strongly recommend reading Morteza Manavi’s <a href="http://weblogs.asp.net/manavi/archive/2010/12/24/inheritance-mapping-strategies-with-entity-framework-code-first-ctp5-part-1-table-per-hierarchy-tph.aspx">series on the subject</a>.<br /><h4>When it works well</h4>If we run this code;<br /><pre class="prettyprint">class Program<br />{<br />    static void Main(string[] args)<br />    {<br />        Database.SetInitializer&lt;MyDb&gt;(new DropCreateDatabaseAlways&lt;MyDb&gt;());<br /><br />        var db = new MyDb();<br />        var t = db.Fruits.FirstOrDefault(f =&gt; f.ID == 1);<br />    }<br />}<br /><br />class MyDb : DbContext<br />{<br />    public DbSet&lt;Fruit&gt; Fruits { get; set; }<br />}<br /><br />abstract class Fruit<br />{<br />    public int ID { get; set; }<br />}<br /><br />class Apple : Fruit<br />{<br />    public int PipCount { get; set; }<br />}<br /><br />class Orange : Fruit<br />{<br />    public int Oranginess { get; set; }<br />}</pre>This SQL is generated: <br /><pre class="prettyprint">SELECT TOP (1) <br />[Extent1].[Discriminator] AS [Discriminator], <br />[Extent1].[ID] AS [ID], <br />[Extent1].[PipCount] AS [PipCount], <br />[Extent1].[Oranginess] AS [Oranginess]<br />FROM [dbo].[Fruits] AS [Extent1]<br />WHERE ([Extent1].[Discriminator] IN ('Apple','Orange')) AND (1 = [Extent1].[ID])</pre>That’s pretty neat; We get all the properties for all the subclasses in a neat way.<br /><h4>When it gets a little weird</h4>When we add a property to a sub class which is a Complex Type then we start having slightly strange results. If we change the class structure to this, for example;<br /><pre class="prettyprint">abstract class Fruit<br />{<br />    public int ID { get; set; }<br />}<br /><br />class Apple : Fruit<br />{<br />    public int PipCount { get; set; }<br />}<br /><br />class Orange : Fruit<br />{<br />    public int Oranginess { get; set; }<br />    public Nutrition Nutrition { get; set; }<br />}<br /><br />[ComplexType]<br />class Nutrition<br />{<br />    public int Calories { get; set; }<br />}</pre>We then get this SQL generated;<br /><pre class="prettyprint">SELECT <br />[Limit1].[Discriminator] AS [Discriminator], <br />[Limit1].[ID] AS [ID], <br />[Limit1].[PipCount] AS [PipCount], <br />[Limit1].[Oranginess] AS [Oranginess], <br />[Limit1].[C1] AS [C1]<br />FROM ( SELECT TOP (1) <br />    [Extent1].[ID] AS [ID], <br />    [Extent1].[PipCount] AS [PipCount], <br />    [Extent1].[Oranginess] AS [Oranginess], <br />    [Extent1].[Discriminator] AS [Discriminator], <br />    CASE WHEN ([Extent1].[Discriminator] = 'Orange') THEN [Extent1].[Nutrition_Calories] END AS [C1]<br />    FROM [dbo].[Fruits] AS [Extent1]<br />    WHERE ([Extent1].[Discriminator] IN ('Apple','Orange')) AND (1 = [Extent1].[ID])<br />)  AS [Limit1]</pre>The structure of the statement is a bit weird, but the key thing to note is the line<br /><pre class="prettyprint">CASE WHEN ([Extent1].[Discriminator] = 'Orange') THEN [Extent1].[Nutrition_Calories] END AS [C1]</pre>EF is starting to use Case statements to choose what to select from SQL, depending on the sub class. If you had more sub-classes then this would start getting bigger. Still, it’s something you can live with.<br /><h4>When it gets bad</h4>The real problems start when we use a complex type on an intermediate class as in this example:<br /><pre class="prettyprint">abstract class Fruit<br />{<br />    public int ID { get; set; }<br />}<br /><br />class Apple : Fruit<br />{<br />    public int PipCount { get; set; }<br />}<br /><br />abstract class Citrus : Fruit<br />{<br />    public Nutrition Nutrition { get; set; }<br />}<br /><br />class Orange : Citrus<br />{<br />    public int Oranginess { get; set; }<br />}<br /><br />class Clementine : Citrus<br />{<br />    public int Sweetness { get; set; }<br />}<br /><br />[ComplexType]<br />class Nutrition<br />{<br />    public int Calories { get; set; }<br />}</pre>What we have is an intermediate “Citrus” class, which inherits from Fruit and which has children. That generates this SQL:<br /><pre class="prettyprint">SELECT <br />[Limit1].[C1] AS [C1], <br />[Limit1].[ID] AS [ID], <br />[Limit1].[C2] AS [C2], <br />[Limit1].[C3] AS [C3], <br />[Limit1].[C4] AS [C4], <br />[Limit1].[C5] AS [C5]<br />FROM ( SELECT TOP (1) <br />    [Extent1].[ID] AS [ID], <br />    CASE WHEN ([Extent1].[Discriminator] = 'Apple') THEN '0X0X' <br />        WHEN ([Extent1].[Discriminator] = 'Orange') THEN '0X1X0X' ELSE '0X1X1X' END AS [C1], <br />    CASE WHEN ([Extent1].[Discriminator] = 'Apple') THEN [Extent1].[PipCount] <br />        WHEN ([Extent1].[Discriminator] = 'Orange') THEN CAST(NULL AS int) END AS [C2], <br />    CASE WHEN ([Extent1].[Discriminator] = 'Apple') THEN CAST(NULL AS int) <br />            WHEN ([Extent1].[Discriminator] = 'Orange') THEN <br />                CASE WHEN (((CASE WHEN ([Extent1].[Discriminator] = 'Orange') THEN cast(1 as bit) <br />                ELSE cast(0 as bit) END) = 1) <br />                OR ((CASE WHEN ([Extent1].[Discriminator] = 'Clementine') THEN cast(1 as bit) <br />                ELSE cast(0 as bit) END) = 1)) THEN [Extent1].[Nutrition_Calories] END <br />                WHEN (((CASE WHEN ([Extent1].[Discriminator] = 'Orange') <br />                THEN cast(1 as bit) ELSE cast(0 as bit) END) = 1) OR <br />                ((CASE WHEN ([Extent1].[Discriminator] = 'Clementine') THEN cast(1 as bit) <br />                ELSE cast(0 as bit) END) = 1)) THEN [Extent1].[Nutrition_Calories] END AS [C3], <br />    CASE WHEN ([Extent1].[Discriminator] = 'Apple') THEN CAST(NULL AS int) <br />        WHEN ([Extent1].[Discriminator] = 'Orange') THEN [Extent1].[Oranginess] END AS [C4], <br />    CASE WHEN ([Extent1].[Discriminator] = 'Apple') THEN CAST(NULL AS int) <br />        WHEN ([Extent1].[Discriminator] = 'Orange') THEN CAST(NULL AS int) ELSE [Extent1].[Sweetness] END AS [C5]<br />    FROM [dbo].[Fruits] AS [Extent1]<br />    WHERE ([Extent1].[Discriminator] IN ('Apple','Orange','Clementine')) AND (1 = [Extent1].[ID])<br />)  AS [Limit1]</pre>As far as I can tell, adding that ComplexType property to the intermediate class causes EF to pursue a strategy in which every single property from every single class other than the root class is selected using CASE clauses. From what I have read, this code looks like it is related to some strategies for performance optimisation with table-per-concrete-type.<br />Now, the above hierarchy is <em>very</em> simple- you can probably imagine what happens when you have a complex class structure.<br />Fixing this problem is a matter of either moving the complex type to the base class or change it to be a navigation property.<br />Microsoft Connect issue <a href="https://connect.microsoft.com/data/feedback/details/726610/complextype-propery-on-intermediate-class-in-inheritance-chain-causes-extremely-verbose-sql#details" target="_blank">here</a>