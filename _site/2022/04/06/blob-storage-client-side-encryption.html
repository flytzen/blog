<!DOCTYPE html> <html lang="en"> <head> <title>Frans' Randomness - Blob Storage Client-Side Encryption</title> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="format-detection" content="telephone=no" /> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="/assets/main.css?v=20180627"> <link type="application/atom+xml" rel="alternate" href="https://www.lytzen.name/feed.xml" title="Frans' Randomness" /> <meta name="description" content="Transparently encrypt blobs in Azure Blob Storage at the Application level with client-side encryption." /> </head> <body> <header class="header" role="banner"> <div class="wrapper"> <a class="header__title h3" rel="author" href="/">Frans&#39; Randomness</a> <nav class="header__nav"> <a class="header__nav-link" href="/talks">Talks</a> <a class="header__nav-link" href="/blog">Blog</a> </nav> </div> </header> <main class="page-content" aria-label="Content"> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post__header"> <div class="wrapper"> <h1 class="post__title" itemprop="name headline">Blob Storage Client-Side Encryption</h1> <div class="post__meta"> <div class="post__author-time"> <span class="post__author" itemprop="author" itemscope itemtype="http://schema.org/Person"> <span itemprop="name">Author <strong>Frans Lytzen</strong></span> </span> <time class="post__date-time dt-published" datetime="2022-04-06T00:00:00+01:00" itemprop="datePublished"> <div class="date-time icon__item"> <svg class="icon__gfx" style="width:24px;height:24px" viewBox="0 0 24 24"> <path d="M19,19H5V8H19M16,1V3H8V1H6V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3H18V1" /> </svg> <span class="icon__txt">06 Apr 2022</span> </div> </time> </div> <div class="tags icon__item"> <svg class="icon__gfx" style="width:24px;height:24px" viewBox="0 0 24 24"> <path d="M5.5,9A1.5,1.5 0 0,0 7,7.5A1.5,1.5 0 0,0 5.5,6A1.5,1.5 0 0,0 4,7.5A1.5,1.5 0 0,0 5.5,9M17.41,11.58C17.77,11.94 18,12.44 18,13C18,13.55 17.78,14.05 17.41,14.41L12.41,19.41C12.05,19.77 11.55,20 11,20C10.45,20 9.95,19.78 9.58,19.41L2.59,12.42C2.22,12.05 2,11.55 2,11V6C2,4.89 2.89,4 4,4H9C9.55,4 10.05,4.22 10.41,4.58L17.41,11.58M13.54,5.71L14.54,4.71L21.41,11.58C21.78,11.94 22,12.45 22,13C22,13.55 21.78,14.05 21.42,14.41L16.04,19.79L15.04,18.79L20.75,13L13.54,5.71Z" /> </svg> <a href="/tags/#Azure" class="icon__txt tag">Azure</a> </div> </div> </div> </header> <div class="wrapper"> <div class="post__content e-content" itemprop="articleBody"> <h1 id="blob-encryption">Blob encryption</h1> <p>Azure provides disk encryption and optional infrastructure encryption, so you can easily comply with “encryption at rest” - at least from a cursory compliance level. But, anyone who has access to your Storage Account can read the blobs. Client-side encryption is built into the Azure Blob Storage SDK. When configured, this will transparently encrypt and decrypt the blob at the application level: You don’t need to change any of the code that reads and writes blobs at all - and your application continues to work as before. But, if you log into the Azure portal and try to download the blob, you will just see encrypted data.</p> <p>In this post, I will explain how this works and show you how to implement it in C# with Azure Key Vault. I am using the Storage SDK 12.x - for which the encryption <a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-encrypt-decrypt-blobs-key-vault?tabs=dotnet">documentation</a> is still not updated at the time of the writing - and the Key Vault SDK 4.3.x.</p> <h1 id="how-does-this-work">How does this work</h1> <p>You <em>can</em> implement this without Key Vault, but that is hard to do securely, so I will only focus on the Key Vault method here.</p> <p>Firstly, all of what I am about to describe is transparently handled by the Blob Storage SDK and Key Vault, once you have wired it up.<br /> Secondly, I need to introduce a couple of concepts before I can explain how the Storage SDK works its magic.</p> <h2 id="symmetric-key-encryption">Symmetric key encryption</h2> <p>Symmetric key encryption means that the same key is used to encrypt and decrypt the data. It is very fast, and it scales really well to large files. Content can be encrypted and decrypted as it is being streamed, without loading everything into memory, and there is only a negligible size overhead (less than 16 bytes).<br /> AES is an example of symmetric key encryption.</p> <p>The problem with symmetric key encryption is that you need to keep that key somewhere safe. What’s worse is that if you encrypt lots of different files with the same symmetric key, an attacker may have a chance of identifying the symmetric key used. The details of this are way beyond the scope of this article.</p> <p>Ideally, you want a unique, randomly created symmetric key for <em>each</em> blob you store - but then where are you going to store all those keys?</p> <h2 id="asymmetric-encryption">Asymmetric Encryption</h2> <p>RSA encryption is a kind of Asymmetric Encryption, is based on factors of large prime numbers and is very secure. It also has the benefit that you use the public key to encrypt the data and the private key to decrypt it. With Azure Key Vault, your code can read the Public key and use it to do encryption locally, but your code cannot read the private key and must send the encrypted content to Key Vault for decryption (I am not sure if the Blob SDK takes advantage of this or not, but you can roll it yourself for high-performance scenarios if needed).</p> <p>The problem with RSA is that it is very slow and doesn’t scale - the C# implementation is limited to encrypting a maximum of 160 bytes. You do not want to encrypt whole files with RSA.</p> <p><em>There are other asymmetric encryption systems, but for the scope of this post I shall stick to RSA.</em></p> <h2 id="envelope-technique">Envelope technique</h2> <p>When you save a Blob with Client-Side Encryption in Azure blob storage, the SDK will create a random, symmetric key (the Content Encryption Key or CEK) and will encrypt the content of the blob with that key.<br /> Next, the SDK will use Key Vault to encrypt the CEK, using an RSA key you have created in the Key Vault. Unless you have a specific reason to do otherwise, create an RSA 2048 key.</p> <p><img src="/assets/createkey.png" alt="Create a Key" /></p> <p>The SDK then stores the encrypted CEK in a Meta Tag field on the blob called <code class="highlighter-rouge">encryptiondata</code>. It also stores some additional data, most importantly the unique identifier for the RSA key that was used to encrypt the symmetric key.</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"EncryptionMode"</span><span class="p">:</span><span class="s2">"FullBlob"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"WrappedContentKey"</span><span class="p">:</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"KeyId"</span><span class="p">:</span><span class="s2">"https://xxx.vault.azure.net/keys/BlobEncryption/7e78c2c3164f458ba4884d3bed00925f"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"EncryptedKey"</span><span class="p">:</span><span class="s2">"FgPb/2nELt5N3mzVIjD</span><span class="se">\u</span><span class="s2">002BKGVmEgpO - XXXXXXX - 7mDINXvgaVw=="</span><span class="p">,</span><span class="w">
            </span><span class="nl">"Algorithm"</span><span class="p">:</span><span class="s2">"RSA-OAEP"</span><span class="w">
        </span><span class="p">},</span><span class="w">
    </span><span class="nl">"EncryptionAgent"</span><span class="p">:</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"Protocol"</span><span class="p">:</span><span class="s2">"1.0"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"EncryptionAlgorithm"</span><span class="p">:</span><span class="s2">"AES_CBC_256"</span><span class="w">
        </span><span class="p">},</span><span class="w">
    </span><span class="nl">"ContentEncryptionIV"</span><span class="p">:</span><span class="s2">"ZA3An4jhVIV8uhRJhlPJKQ=="</span><span class="p">,</span><span class="w">
    </span><span class="nl">"KeyWrappingMetadata"</span><span class="p">:</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"EncryptionLibrary"</span><span class="p">:</span><span class="s2">"azsdk-net-Azure.Storage.Blobs/12.11.0</span><span class="se">\u</span><span class="s2">002B594b8851940eb859860cff9aaaafbbb092df59d6 (.NET 5.0.15; Linux 5.10.16.3-microsoft-standard-WSL2 #1 SMP Fri Apr 2 22:23:49 UTC 2021)"</span><span class="w">
        </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>When the SDK later <em>reads</em> the blob, it also retrieves the <code class="highlighter-rouge">encryptiondata</code> meta tag. Armed with that information, the SDK then asks Key Vault to decrypt the encrypted Content Encryption Key and then uses that symmetric key to decrypt the contents of the blob.</p> <p>This is known as the “envelope technique”. It is a tried and tested technique that combines the best features of AES and RSA encryption.</p> <h2 id="key-versioning-or-rotation">Key Versioning or Rotation</h2> <p>It is common practice to “rotate” encryption keys to reduce the impact of a key being leaked. If all your blobs were encrypted with the same key and that key was leaked, all your files would be vulnerable. But if you change the key once in a while, the attacker will only get access to a limited number of blobs.</p> <p>Each blob has its own, individual symmetric encryption key, so there is nothing to “rotate” there. If you want to change the symmetric key for a particular blob for some reason, you need to read it in code and then re-save it.</p> <p>But what about that RSA key? If an attacker gets hold of that, they can decrypt the symmetric key for each of your blobs and then read them. Fortunately, Key Vault has a concept of “versions” of a key, and even has a new “key rotation policy” in preview, which automatically creates a new version at a set interval. Each “version” of a key is really a completely different key. But the mechanism means you can ask your Key Vault for the latest version of a specific key name and you will get a Key Identifier that includes a version number. That key can then be used to encrypt the data in the blob and the full Key Identifier, including the version number, is stored in the <code class="highlighter-rouge">encryptiondata</code> meta tag.</p> <p>When it comes time to read the blob, the Blob SDK reads the exact key version that was used to encrypt the content encryption key from the metadata. As a matter of fact, the Key Identifier includes the address of the Key Vault so if you need to use more than Key Vault for the same Blob Storage account, for example during a migration, you can.</p> <p><img src="/assets/keyversions.png" alt="Key Versions" /></p> <h1 id="implementing-this-in-c">Implementing this in C#</h1> <p>For this example I am using the following packages:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;PackageReference Include="Azure.Identity" Version="1.5.0" /&gt;
    &lt;PackageReference Include="Azure.Security.KeyVault.Keys" Version="4.3.0" /&gt;
    &lt;PackageReference Include="Azure.Storage.Blobs" Version="12.11.0" /&gt;
</code></pre></div></div> <p>Azure Identity is only included so I can use Managed Identity to connect to Key Vault and Blob Storage. You do not need to do that; a Connection String for Blob Storage and a Service Principal for Key Vault will work just as well.</p> <h2 id="permissions">Permissions</h2> <p>In this example, I am using Managed Identity to access both Key Vault and Blob Storage. For Key Vault, if you are using the RBAC roles, the “user” needs at least the <code class="highlighter-rouge">Key Vault Crypto User</code> role. In order to create and rotate keys, you need the <code class="highlighter-rouge">Key Vault Crypto Officer</code> role (do not give that to your application).</p> <p>In Blob Storage SDK 12, most of what you do starts with getting a <code class="highlighter-rouge">BlobServiceClient</code>. The method below creates a <code class="highlighter-rouge">BlobServiceClient</code> that will transparently encrypt and decrypt data as blobs are written and read.</p> <p>You should probably set this up to be a Singleton in your DI. The only thing to be mindful of is that if you want to use Key Rotation (and you should) then you should re-create <code class="highlighter-rouge">BlobServiceClient</code> once in a while - on a timescale that is similar to your key rotation timescale. The reason is that the <em>encryption</em> key is only read during the creation of the <code class="highlighter-rouge">BlobServiceClient</code>. The old version of the key will continue to work even after a new version is created (unless you explicitly disable it in Key Vault), so you don’t have to be very precise about the timings. But, you do obviously want to start using the new key version at some point, otherwise the whole rotation thing is pointless.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">BlobServiceClient</span> <span class="nf">GetBlobServiceClient</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">keyVaultUri</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">configuration</span><span class="p">.</span><span class="n">GetValue</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="s">"KeyVaultUri"</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">keyIdentifier</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">configuration</span><span class="p">.</span><span class="n">GetValue</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="s">"BlobEncryptionKeyName"</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">azureCredentials</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DefaultAzureCredential</span><span class="p">();</span>

    <span class="c1">// NOTE: This reads the current key version and uses that to encrypt Content Encryption Keys going forward</span>
    <span class="c1">// Problem is that when the key gets rotated, at some point you should update the key being used</span>
    <span class="c1">// So, you do need to refresh this occasionally!</span>
    <span class="kt">var</span> <span class="n">keyClient</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">KeyClient</span><span class="p">(</span><span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="n">keyVaultUri</span><span class="p">),</span> <span class="n">azureCredentials</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">key</span> <span class="p">=</span> <span class="n">keyClient</span><span class="p">.</span><span class="nf">GetKey</span><span class="p">(</span><span class="n">keyIdentifier</span><span class="p">);</span>  <span class="c1">// this gets the current version of the named key</span>

    <span class="c1">// The cryptoClient is used to encrypt the Content Encryption Key</span>
    <span class="kt">var</span> <span class="n">cryptoClient</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CryptographyClient</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">azureCredentials</span><span class="p">);</span>
    <span class="c1">// The keyResolver is the thing that can be given a Key Identifier and get a reference to the RSA key so the CEK can be decrypted</span>
    <span class="kt">var</span> <span class="n">keyResolver</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">KeyResolver</span><span class="p">(</span><span class="k">new</span> <span class="nf">DefaultAzureCredential</span><span class="p">());</span>

    <span class="c1">// This and the next bit just sets up the configuration options to be used when creating the BlobServiceClient</span>
    <span class="kt">var</span> <span class="n">encryptionOptions</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ClientSideEncryptionOptions</span><span class="p">(</span><span class="n">ClientSideEncryptionVersion</span><span class="p">.</span><span class="n">V1_0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">KeyEncryptionKey</span> <span class="p">=</span> <span class="n">cryptoClient</span><span class="p">,</span>
        <span class="n">KeyResolver</span> <span class="p">=</span> <span class="n">keyResolver</span><span class="p">,</span>
        <span class="n">KeyWrapAlgorithm</span> <span class="p">=</span> <span class="s">"RSA-OAEP"</span>  <span class="c1">// There are other options, use this for an RSA 2048 key</span>
    <span class="p">};</span>

    <span class="kt">var</span> <span class="n">blobClientOptions</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SpecializedBlobClientOptions</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">ClientSideEncryption</span> <span class="p">=</span> <span class="n">encryptionOptions</span>
    <span class="p">};</span>

    <span class="c1">// Finally, create the BlobServiceClient with the configuration options to use encryption.</span>
    <span class="kt">var</span> <span class="n">blobServiceUrl</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">configuration</span><span class="p">.</span><span class="n">GetValue</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="s">"BlobServiceUri"</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">BlobServiceClient</span><span class="p">(</span><span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="n">blobServiceUrl</span><span class="p">),</span> <span class="n">azureCredentials</span><span class="p">,</span> <span class="n">blobClientOptions</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div> <h1 id="afterthought">Afterthought</h1> <p><a href="https://www.neworbit.co.uk/azure">NewOrbit</a> is an Azure Gold Partner and Azure Reseller (“Direct CSP”) as well as development house. We help other development companies to get more out of Azure, with a particular focus on reducing costs and making systems more secure. If you would like to buy your Azure from people who design and develop systems on Azure every day, give us a <a href="https://neworbit.co.uk/#contact">shout</a> or ping me on <a href="https://twitter.com/flytzen">Twitter</a>. We usually give you a “trial”, in the form of a Cost, Infrastructure or Security review so you can see if we can help you and if you like working with us.</p> </div> <div id="disqus_thread"></div> <script> var disqus_config = function () { this.page.url = 'https://www.lytzen.name/2022/04/06/blob-storage-client-side-encryption.html'; this.page.identifier = '/2022/04/06/blob-storage-client-side-encryption.html'; }; (function() { var d = document, s = d.createElement('script'); s.src = 'https://flytzen.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> <a class="u-url" href="/2022/04/06/blob-storage-client-side-encryption.html" hidden></a> </div> </article> </main> <footer class="footer"> <div class="wrapper"> <div class="social-links"> <a rel="me" href="https://github.com/flytzen" target="_blank" alt="GitHub"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon"> <path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z" /> </svg> </a> <a rel="me" href="https://www.linkedin.com/in/flytzen/" target="_blank" alt="LinkedIn"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon"> <path d="M21,21H17V14.25C17,13.19 15.81,12.31 14.75,12.31C13.69,12.31 13,13.19 13,14.25V21H9V9H13V11C13.66,9.93 15.36,9.24 16.5,9.24C19,9.24 21,11.28 21,13.75V21M7,21H3V9H7V21M5,3A2,2 0 0,1 7,5A2,2 0 0,1 5,7A2,2 0 0,1 3,5A2,2 0 0,1 5,3Z" /> </svg> </a> <a rel="me" href="https://twitter.com/flytzen" target="_blank"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon" alt="Twitter"> <path d="M22.46,6C21.69,6.35 20.86,6.58 20,6.69C20.88,6.16 21.56,5.32 21.88,4.31C21.05,4.81 20.13,5.16 19.16,5.36C18.37,4.5 17.26,4 16,4C13.65,4 11.73,5.92 11.73,8.29C11.73,8.63 11.77,8.96 11.84,9.27C8.28,9.09 5.11,7.38 3,4.79C2.63,5.42 2.42,6.16 2.42,6.94C2.42,8.43 3.17,9.75 4.33,10.5C3.62,10.5 2.96,10.3 2.38,10C2.38,10 2.38,10 2.38,10.03C2.38,12.11 3.86,13.85 5.82,14.24C5.46,14.34 5.08,14.39 4.69,14.39C4.42,14.39 4.15,14.36 3.89,14.31C4.43,16 6,17.26 7.89,17.29C6.43,18.45 4.58,19.13 2.56,19.13C2.22,19.13 1.88,19.11 1.54,19.07C3.44,20.29 5.7,21 8.12,21C16,21 20.33,14.46 20.33,8.79C20.33,8.6 20.33,8.42 20.32,8.23C21.16,7.63 21.88,6.87 22.46,6Z" /> </svg> </a> <a rel="me" href="https://hachyderm.io/@flytzen" target="_blank"> <svg style="width:24px;height:24px" fill="currentColor" viewBox="0 0 24 24" class="social-icon" alt="Mastodon"> <path d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a3.614 3.614 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522c0-.859.22-1.541.66-2.046.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764.442.505.661 1.187.661 2.046v4.203z"/> </svg> </a> </div> <div class="copyright"> &copy; Frans Lytzen 2022 </div> </div> </footer> </body> </html>
