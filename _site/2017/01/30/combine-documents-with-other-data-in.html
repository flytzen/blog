<!DOCTYPE html> <html lang="en"> <head> <title>Frans' Randomness - Combine documents with other data in Azure Search</title> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="format-detection" content="telephone=no" /> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="/assets/main.css?v=20180627"> <link type="application/atom+xml" rel="alternate" href="https://www.lytzen.name/feed.xml" title="Frans' Randomness" /> <meta name="description" content="Azure Search has built-in support for indexing documents in blob storage, which works great. But what if you want to combine&nbsp;the documents with other data, for example if you are building a recruitment system and want to search on, say, location and CV content at the same time?TL;DR; Indexers in..." /> </head> <body> <header class="header" role="banner"> <div class="wrapper"> <a class="header__title h3" rel="author" href="/">Frans&#39; Randomness</a> <nav class="header__nav"> <a class="header__nav-link" href="/talks">Talks</a> <a class="header__nav-link" href="/blog">Blog</a> </nav> </div> </header> <main class="page-content" aria-label="Content"> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post__header"> <div class="wrapper"> <h1 class="post__title" itemprop="name headline">Combine documents with other data in Azure Search</h1> <div class="post__meta"> <div class="post__author-time"> <span class="post__author" itemprop="author" itemscope itemtype="http://schema.org/Person"> <span itemprop="name">Author <strong>Frans Lytzen</strong></span> </span> <time class="post__date-time dt-published" datetime="2017-01-30T13:07:00+00:00" itemprop="datePublished"> <div class="date-time icon__item"> <svg class="icon__gfx" style="width:24px;height:24px" viewBox="0 0 24 24"> <path d="M19,19H5V8H19M16,1V3H8V1H6V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3H18V1" /> </svg> <span class="icon__txt">30 Jan 2017</span> </div> </time> </div> <div class="tags icon__item"> <svg class="icon__gfx" style="width:24px;height:24px" viewBox="0 0 24 24"> <path d="M5.5,9A1.5,1.5 0 0,0 7,7.5A1.5,1.5 0 0,0 5.5,6A1.5,1.5 0 0,0 4,7.5A1.5,1.5 0 0,0 5.5,9M17.41,11.58C17.77,11.94 18,12.44 18,13C18,13.55 17.78,14.05 17.41,14.41L12.41,19.41C12.05,19.77 11.55,20 11,20C10.45,20 9.95,19.78 9.58,19.41L2.59,12.42C2.22,12.05 2,11.55 2,11V6C2,4.89 2.89,4 4,4H9C9.55,4 10.05,4.22 10.41,4.58L17.41,11.58M13.54,5.71L14.54,4.71L21.41,11.58C21.78,11.94 22,12.45 22,13C22,13.55 21.78,14.05 21.42,14.41L16.04,19.79L15.04,18.79L20.75,13L13.54,5.71Z" /> </svg> <a href="/tags/#Azure" class="icon__txt tag">Azure</a> </div> </div> </div> </header> <div class="wrapper"> <div class="post__content e-content" itemprop="articleBody"> Azure Search has built-in support for indexing documents in blob storage, which works great. But what if you want to <i>combine</i>&nbsp;the documents with other data, for example if you are building a recruitment system and want to search on, say, location and CV content at the same time?<br /><br /><b>TL;DR; </b>Indexers in Azure Search uses a "create or update" approach; as long as your different indexers use the same <i>id, </i>they can all write data to the same document in the index.<br /><br /><h2>Terminology in Azure Search</h2><div><i>(deliberately simplified and made Azure Search specific)</i><br /><i><br /></i></div><div>An <b>index</b>&nbsp;in Azure Search is more like a table in an RDBMS or a collection in a document-based database. It has a specific "schema" (the index definition) that specifies the structure of the <b>documents</b><i>&nbsp;</i>stored in the index.</div><div><br /></div><div>A <b>document</b>&nbsp;is a single entity in Azure Search, think "record" or (indeed) document in a document database. It has an <i>id</i>&nbsp;that is unique within that index.</div><div><br /></div><div>An <b>indexer</b>&nbsp;is something that takes data from a source, like Blob storage, SQL or something else, re-formats it and writes it to documents in an index in Azure Search.<br /><br />A <b>data source</b>&nbsp;is a definition in Azure Search of somewhere that an <b>indexer</b>&nbsp;can read data from. It's sort of like a connection string.<br /><br /></div><h2>Scenario</h2><div>The specific scenario I have is the need to build a database of candidates for a recruitment system. I want to be able to search the contents of CVs, but I also want to be able to filter and use faceted search on various bits of data about the candidate themselves, such as location, qualification and so on.<br /><br /></div><div>Azure Search provides built-in functionality to read the contents from a range of files stored in Azure Blob Storage, so that sounded pretty ideal; just upload the CVs to blob storage, point Azure search to it and be done. Of course, that would not combine it with the other candidate data. Initially I thought about several options;<br /><ul><li>I could extract the content of the files myself and write code to combine it with candidate data in code. But extracting content out of files is not a trivial problem.</li><li>I could let Azure Search index the files, then write code to extract the content back out of Azure Search and write it back to another index. But that seemed like a very long-winded solution.</li><li>I asked Microsoft if I could somehow access the content-extraction feature directly. But you can't.</li></ul></div><br /><h2>The solution</h2><div><a href="https://twitter.com/liamca">Liam Cavanagh</a>&nbsp;gave me the outline solution with this statement;</div><blockquote class="tr_bq">Leverage Blob Storage with Data Store (such as Azure SQL or DocumentDB):&nbsp; If you store your files in Azure Blob storage, and your structured data in something like Azure SQL or DocumentDB, you can use both the Azure Search Blob Indexer as well as the Azure Search SQL or DocumentDB Indexer together.&nbsp; <b>The only trick is to make sure that the unique key that is defined for each document matches between Blob and the structured data store</b>.&nbsp; For example, if you choose to use the Base64 Encoded filename as the key, then you would need to make sure that the matching content in your structured datastore also contains this value.&nbsp; That way the Indexer which does something called MergeOrUpdate, will first take a row from say the Blob Storage and insert it as a new row in Azure Search and then it will bring in the data from the structured data store and update the existing row with the new fields.</blockquote><br /><div>With a bit more help from Liam I put together the sample solution outlined below. I should also mention that in this solution I am using the built-in tools in Azure Search to read data directly from SQL and Blob storage. If you wanted to use code to manually write to the index instead of letting Azure Search read from SQL then you can do that too, of course. Or read from some of the other supported data sources, or combine it all or...</div><br /><h2>Implementation</h2><div>You'll need to create an Azure Search account and whatever data sources you want to use. You can do a number of the steps directly in the Azure Portal, though not all of them. For the ones you can't I will show the appropriate JSON payload you need to send. It is ridiculously easy with something like <a href="https://www.getpostman.com/">Postman</a>. You just need to make sure you add two headers to your requests;</div><div><ul><li>Content-Type : application/json</li><li>api-key : [an admin key for your Azure Search instance]</li></ul></div><div style="height: 480px; margin: 10px; position: relative; width: 640px;">In summary, this is what we are going to build:<br /><iframe allowfullscreen="" frameborder="0" id="wGZtguhjzZug" src="https://www.lucidchart.com/documents/embeddedchart/ce4e64ec-6570-48a9-a412-756e445e9d84" style="height: 480px; width: 640px;"></iframe><br /></div><br /><br /><h4>Create the Index</h4><div>You can create a new index directly in the Azure Portal, which is what I did. It has a very nice editor that makes it quite easy. I ended up with something looking like this;<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-yV3arlG8Z-c/WI41d2CtLnI/AAAAAAAAKSo/Rjj-6L0M0sQvH4EyVoTqMYFKIp0NBMNUACLcB/s1600/CandidatesIndex.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="268" src="https://2.bp.blogspot.com/-yV3arlG8Z-c/WI41d2CtLnI/AAAAAAAAKSo/Rjj-6L0M0sQvH4EyVoTqMYFKIp0NBMNUACLcB/s640/CandidatesIndex.PNG" width="640" /></a></div><br /></div><div>Please note the "<b>content</b>" field; When Azure Search indexes files, it will place the content of those files in the <b>content</b>&nbsp;field. <b>Id</b>&nbsp;is there by default and we need that, so leave it alone, but the remaining fields can be whatever you like. I put a <b>name</b> in there for the Candidate Name and the last two fields are some fields I added so I could experiment with faceted search.<br /><br /></div><h4>Create the data sources</h4><div>Next we need to tell Azure Search where it can get the data - we need to create the Data Sources.</div><div>You can't create a Data Source on it's own in the Portal; there is an option to "import data" but that combines setting up the data source with the index and the indexer so we can't use it for our purposes.<br />Time to start posting JSON (see above).<br /><br /></div><div>POST these to https://<i>yoursearchservice</i>.search.windows.net/datasources?api-version=2016-09-01 and replace the XXX with valid connection strings.<br /><pre class="prettyprint">{<br />    "name" : "blobcvs",<br />    "type" : "azureblob",<br />    "credentials" : { "connectionString" : "XXX" },<br />    "container" : { "name" : "cvs" }<br />}<br /><br />{<br />    "name" : "candidates",<br />    "type" : "azuresql",<br />    "credentials" : { "connectionString" : "XXX" },<br />    "container" : { "name" : "Candidates" }<br />} <br /></pre>This tells Azure Search how to access your data.<br /><br /></div><h4>Create the indexers</h4><div>POST these to&nbsp;https://<i>yoursearchservice</i>.search.windows.net/indexers?api-version=2016-09-01<br /><pre class="prettyprint">{<br />    "name" : "candidateindexer",<br />    "dataSourceName" : "candidates",<br />    "targetIndexName" : "candidates",<br />    "fieldMappings" : [ { "sourceFieldName" : "Thingiemajics", <br />                          "mappingFunction" : { "name" : "jsonArrayToStringCollection" } <br />                      } ]<br />}<br /></pre>This tells Azure Search to take the data in the SQL database specified in the SQL data source and create a document in Azure Search for each row. Azure Search will <i>automatically </i>match fields with the same names; I've got an Id field as well as Name, Type and Thingiemajics columns in SQL. The only one that is a bit special is Thingiemajics; I'm storing an array of tag values in that field in SQL in the format ["red", "white", "blue"] and putting that mapping function in there tells Azure Search to make them individual tags that can be filtered individually. See <a href="https://docs.microsoft.com/en-us/azure/search/search-indexer-field-mappings#jsonArrayToStringCollectionFunction">the docs</a>&nbsp;for more details.<br /><br />Before I create the indexer for the <i>files</i>, let me just take a little detour. If you remember, the original statement was that for this to work, the two different indexers need to use the <i>same</i>&nbsp;id for data about the same candidate. The SQL indexer in my example uses the database ID of the candidate and we need to ensure that when Azure Search indexes the CV for a candidate it returns the same index. By <i>default</i>&nbsp;Azure Search will use the filename, which is obviously no good in this situation. The way I solved this was to add a custom meta data property to the blob when I uploaded it to Azure Blob Storage, something like this:<br /><br /><pre class="prettyprint">using (var fileStream = System.IO.File.OpenRead(file))<br />{<br />   await blob.UploadFromStreamAsync(fileStream);<br />}<br />blob.Metadata.Add("mykey", identifier);<br />await blob.SetMetadataAsync();<br /></pre>Here I have called it "mykey", but it could be called anything.</div><div><br /></div><div>On to the indexer, which is created with this:<br /><pre class="prettyprint">{<br />    "name" : "cvindexer",<br />    "dataSourceName" : "blobcvs",<br />    "targetIndexName" : "candidates",<br />    "fieldMappings" : [ { "sourceFieldName" : "mykey", "targetFieldName" : "id" } ],<br />    "parameters" : { "configuration" : { "failOnUnsupportedContentType" : false } }<br />}<br /></pre>The most important thing here is that I tell Azure Search to take the metadata property "mykey" and map it to the "id" field in my index. That's all that is required to ensure the contents of the CV ends up in the same search document as the other Candidate information.</div><br /><h2>Notes</h2><div>In my solution here I added an ID property to the blob meta data. I could, of course, have gone the other way instead and added the blob reference to the SQL data and then remapped that reference to "id" in the SQL indexer. Both approaches are equally valid, both have pros and cons, including the need to manually maintain uniqueness of the ID property and the need to base64 encode filenames.<br /><br />You should also note that this works because the different datasources do not have any of the same field names; if the two indexers both return the same field, one will win and delete the data from the other one.</div> </div> <div id="disqus_thread"></div> <script> var disqus_config = function () { this.page.url = 'https://www.lytzen.name/2017/01/30/combine-documents-with-other-data-in.html'; this.page.identifier = '/2017/01/30/combine-documents-with-other-data-in.html'; }; (function() { var d = document, s = d.createElement('script'); s.src = 'https://flytzen.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> <a class="u-url" href="/2017/01/30/combine-documents-with-other-data-in.html" hidden></a> </div> </article> </main> <footer class="footer"> <div class="wrapper"> <div class="social-links"> <a href="https://github.com/flytzen" target="_blank"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon"> <path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z" /> </svg> </a> <a href="https://www.linkedin.com/in/flytzen/" target="_blank"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon"> <path d="M21,21H17V14.25C17,13.19 15.81,12.31 14.75,12.31C13.69,12.31 13,13.19 13,14.25V21H9V9H13V11C13.66,9.93 15.36,9.24 16.5,9.24C19,9.24 21,11.28 21,13.75V21M7,21H3V9H7V21M5,3A2,2 0 0,1 7,5A2,2 0 0,1 5,7A2,2 0 0,1 3,5A2,2 0 0,1 5,3Z" /> </svg> </a> <a href="https://twitter.com/flytzen" target="_blank"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon"> <path d="M22.46,6C21.69,6.35 20.86,6.58 20,6.69C20.88,6.16 21.56,5.32 21.88,4.31C21.05,4.81 20.13,5.16 19.16,5.36C18.37,4.5 17.26,4 16,4C13.65,4 11.73,5.92 11.73,8.29C11.73,8.63 11.77,8.96 11.84,9.27C8.28,9.09 5.11,7.38 3,4.79C2.63,5.42 2.42,6.16 2.42,6.94C2.42,8.43 3.17,9.75 4.33,10.5C3.62,10.5 2.96,10.3 2.38,10C2.38,10 2.38,10 2.38,10.03C2.38,12.11 3.86,13.85 5.82,14.24C5.46,14.34 5.08,14.39 4.69,14.39C4.42,14.39 4.15,14.36 3.89,14.31C4.43,16 6,17.26 7.89,17.29C6.43,18.45 4.58,19.13 2.56,19.13C2.22,19.13 1.88,19.11 1.54,19.07C3.44,20.29 5.7,21 8.12,21C16,21 20.33,14.46 20.33,8.79C20.33,8.6 20.33,8.42 20.32,8.23C21.16,7.63 21.88,6.87 22.46,6Z" /> </svg> </a> </div> <div class="copyright"> &copy; Frans Lytzen 2018 </div> </div> </footer> </body> </html>
