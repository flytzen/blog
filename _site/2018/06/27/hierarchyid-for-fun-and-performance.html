<!DOCTYPE html> <html lang="en"> <head> <title>Frans' Randomness - Hierarchy IDs for Fun and Performance</title> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="format-detection" content="telephone=no" /> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="/assets/main.css?v=20180627"> <link type="application/atom+xml" rel="alternate" href="https://www.lytzen.name/feed.xml" title="Frans' Randomness" /> <meta name="description" content="Storing hierarchies in a database is easy - but applying hierarchical security and configuration can be very difficult and a significant performance problem. Hierarchy IDs can alleviate this, at the cost of a bit more complexity at write time." /> </head> <body> <header class="header" role="banner"> <div class="wrapper"> <a class="header__title h3" rel="author" href="/">Frans&#39; Randomness</a> <nav class="header__nav"> <a class="header__nav-link" href="/talks">Talks</a> <a class="header__nav-link" href="/blog">Blog</a> </nav> </div> </header> <main class="page-content" aria-label="Content"> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post__header"> <div class="wrapper"> <h1 class="post__title" itemprop="name headline">Hierarchy IDs for Fun and Performance</h1> <div class="post__meta"> <div class="post__author-time"> <span class="post__author" itemprop="author" itemscope itemtype="http://schema.org/Person"> <span itemprop="name">Author <strong>Frans Lytzen</strong></span> </span> <time class="post__date-time dt-published" datetime="2018-06-27T00:00:00+01:00" itemprop="datePublished"> <div class="date-time icon__item"> <svg class="icon__gfx" style="width:24px;height:24px" viewBox="0 0 24 24"> <path d="M19,19H5V8H19M16,1V3H8V1H6V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3H18V1" /> </svg> <span class="icon__txt">27 Jun 2018</span> </div> </time> </div> <div class="tags icon__item"> <svg class="icon__gfx" style="width:24px;height:24px" viewBox="0 0 24 24"> <path d="M5.5,9A1.5,1.5 0 0,0 7,7.5A1.5,1.5 0 0,0 5.5,6A1.5,1.5 0 0,0 4,7.5A1.5,1.5 0 0,0 5.5,9M17.41,11.58C17.77,11.94 18,12.44 18,13C18,13.55 17.78,14.05 17.41,14.41L12.41,19.41C12.05,19.77 11.55,20 11,20C10.45,20 9.95,19.78 9.58,19.41L2.59,12.42C2.22,12.05 2,11.55 2,11V6C2,4.89 2.89,4 4,4H9C9.55,4 10.05,4.22 10.41,4.58L17.41,11.58M13.54,5.71L14.54,4.71L21.41,11.58C21.78,11.94 22,12.45 22,13C22,13.55 21.78,14.05 21.42,14.41L16.04,19.79L15.04,18.79L20.75,13L13.54,5.71Z" /> </svg> <a href="/tags/#Databases" class="icon__txt tag">Databases</a> <a href="/tags/#Performance" class="icon__txt tag">Performance</a> <a href="/tags/#SQL" class="icon__txt tag">SQL</a> <a href="/tags/#CosmosDB" class="icon__txt tag">CosmosDB</a> </div> </div> </div> </header> <div class="wrapper"> <div class="post__content e-content" itemprop="articleBody"> <p>Many systems have a <em>hierarchy</em> in the data. This may be an organisation hierarchy, or maybe a hierarchy caused by a multi-tenant system or a combination thereof.<br /> It’s relatively easy to model a hierarchy in a relational or document database - it is much harder to effectively filter which part of the tree a given user can see or act on. You may find yourself traversing up or down the tree or making multi-table joins.<br /> A simpler solution is to use a Hierarchy ID. In a relational database, you would implement this as a string field with a delimiter-separated list of its parents, for example <code class="highlighter-rouge">120/23/47/19</code>. If a user is allowed to see everything from <code class="highlighter-rouge">120/23</code> downwards, you can easily search for all the records where the Hierarchy ID starts with <code class="highlighter-rouge">120/23</code> (indexes will work well with that). In document databases it ma be more optimal to have an array of all the Ancestor IDs instead of a string value.</p> <p>This post explores the use of Hierarchy IDs to make filtering easy and performant. In addition, it has some pointers about how to set up hierarchical configuration using the same Hierarchy ID you are implementing anyway. Of course, you could just use a graph database and then it’s a different story altogether.</p> <h1 id="the-problem">The problem</h1> <p>A multi-tenant hierarchy may look like this:</p> <p><img src="https://www.lytzen.name/assets/fixedhierarchy.png" alt="Fixed Hierarchy" /></p> <p>We’ll call this is a <em>fixed</em> hierarchy as it has a fixed depth and different types at different levels.</p> <p>An organisational hierarchy may look like this; <img src="https://www.lytzen.name/assets/selfreferrentialhierarchy.png" alt="Self-referential Hierarchy" /></p> <p>We’ll call this a <em>self-referential</em> hierarchy as each layer in the hierarchy refers to parent/children of the same type.</p> <p>At <a href="https://neworbit.co.uk">NewOrbit</a> we sometimes build multi-tenanted systems which has resellers, who have system customers, who in turn have organisational hierarchies so it can quickly become a very deep hierarchy.</p> <p>When you are creating your data structure, whether in a relational database such as Azure SQL or a document database such as Mongo or CosmosDb, you will typically have a Parent ID on records in the hierarchy as illustrated above. This is easy at write time and makes it relatively easy to traverse the hierarchy both up and down. However, when you need to get access to a only a part of the tree or indeed multiple subsets of the tree then it becomes very hard to query efficiently and performantly.</p> <p>As an example with the self-referential hierarchy, imagine in the illustration above that a given user is allowed to see the details of anybody who is in Bob’s hierarchy; you’d need to write a recursive function to keep drilling down the layers until there are no more subordinates. That means running many different SQL queries or using UDFs (which in turn will run a recursive function).</p> <p>Alternatively in the fixed hierarchy, imagine if a given user has access to see all the projects for three separate branches and they want to see a list of all tasks across all projects they have access to. Or imagine that a Reseller user has access to see all the details for all their Customers, but not for any other Customer - and they want to see a list of all Projects (okay, maybe not the best example in the world, but you get the idea). In that scenario you’d probably write some code that JOINs all the way up the hierarchy and out to various permissions tables, such as “are they in the list that can see the project or in the list that can see the branch or in the list that can see the customer or in the list that can see the reseller”. It may not be that hard to write the code, but it’s easy to end up with a 20-table <code class="highlighter-rouge">JOIN</code>, which is expensive on a relational database - and impossible if you use CosmosSB which does not support <code class="highlighter-rouge">JOIN</code>s.</p> <p>In this post I am primarily focusing on how to <em>filter</em> the data so a user can only see the data they are allowed in an efficient manner. There are other hierarchy scenarios, in particular around set based operations and there are other patterns that are better suited to those than what I am showing here. I highly recommend <a href="https://www.amazon.co.uk/Hierarchies-Smarties-Kaufmann-Management-Systems/dp/0123877334">Joe Celko’s Trees and Hierarchies in SQL for Smarties</a> for understanding more about this. In fact, the lessons that I am expounding on in this post are based on what I learnt from that book many moons ago. Even if you use a document database, it’s still a good read to understand the patterns.</p> <h1 id="how-to-store-hierarchy-ids">How to store Hierarchy IDs</h1> <p>As discussed above, you will typically have some kind of Parent ID on each node in the hierarchy (though it’s usually called something more meaningful, such as CustomerID or ManagerID). The trick to efficient querying is to maintain a <em>Hierarchy ID</em> on each record that has all the parent IDs all the way up the tree.<br /> In a relational database, you would store it as a text string like this (for the Task in the fixed hierarchy example above); <code class="highlighter-rouge">10/20/57/2/1047</code>.</p> <p>In a Document Database you can do the same or use a slightly more efficient approach, which is to store an <code class="highlighter-rouge">array</code> of Ancestor IDs. If your documents use <code class="highlighter-rouge">GUID</code>s for IDs, then you can just put all the Ancestor IDs in the array. Otherwise (and only in the fixed hierarchy) you could prefix each ID with its record type - but that starts making it too blurry in my opinion.</p> <p>SQL Server has a native Hierarchy ID data type that gives you a few convenience functions, but it is not mapped in Entity Framework so if you use EF you may prefer to just use a normal string.</p> <h1 id="querying">Querying</h1> <p>In order to query the database you need to be able to search on Hierarchy IDs so ensure there is an index on the field for performance. Next you need to know which Hierarchy IDs a user is allowed to see.</p> <p>In the case of a <strong>relational database</strong> you have a couple of options;</p> <ul> <li>If a user will only have access to a few Hierarchy IDs, then you can simply have those on listed on whatever user object (such as a ClaimsPrincipal) you are passing around in your code and you can then do some SQL along the lines of <code class="highlighter-rouge">SELECT FROM xx WHERE HierarchyID LIKE "123/23%" OR HierarchyID LIKE "516/67/43/109%" </code>. If you have many Hierarchy IDs per user then this will end up with a lot of <code class="highlighter-rouge">OR</code> statements which can really hurt performance, so be careful.</li> <li>If a user has access to many Hierarchy IDs it may be better to maintain a Hierarchy ID table in the database, with each row having a user ID and a Hierarchy ID and then <code class="highlighter-rouge">INNER JOIN</code> or <code class="highlighter-rouge">APPLY</code> to that table in your query.<br /> Just be mindful that if a user is allowed two Hierarchy IDs where one is a subset of the other, you will get duplicate records so you need to either use <code class="highlighter-rouge">DISTINCT</code> or remove such “duplicates” from the User-HierarchyID table before <code class="highlighter-rouge">JOIN</code>ing.</li> </ul> <p>In the case of a <strong>document database</strong> that doesn’t support <code class="highlighter-rouge">JOIN</code>s your only option is to keep that list of allowed Hierarchy IDs or Ancestor IDs and then use OR statements.</p> <h1 id="mutability-of-the-hierarchy">Mutability of the hierarchy</h1> <p>Some hierarchies are essentially immutable, others can change at times. For example, in the example above with customers and projects, it is exceedingly unlikely that a customer will move between resellers or a project will move between customers. In that scenario you can probably treat the Hierarchy ID as write-only and just set it once when you create the records. In the rare circumstance where you may have to change it, you can deal with that as a one-off and handle it manually.</p> <p>Organisation hierarchies, in particular, have an annoying habit of changing over time. If someone’s manager changes, you have to update the Hierarchy IDs all the way down the tree. Depending on the potential size of the tree and your security requirements, this may be done in different ways. Bear in mind that when the CEO of a 100,000 person company changes, that’s a lot of records to update. In most scenarios you can just have a simple function that recurses through all the affected records and updates each one in turn. You may implement this at the database level or in application code, depending on your requirements. In a relational database you may be tempted to wrap this entire thing in a transaction, but be mindful that this may escalate to a table lock, which may effectively lock your whole system up. Alternatively, updating each record in turn may mean that for a few minutes (for a very large change) some users will see a mixture of the records they used to be able to see and the records they are going to be able to see. The user should never see records they weren’t meant to see; it may just take a few minutes to remove all the records they used to be able to see and add all the new records. Users may also need to re-login if you are caching their list of allowed Hierarchy IDs in a session object of some kind. Mostly, these changes are infrequent - at least changes that affect many records - so it’s usually not something to worry too much about, as long as you understand it for your system.</p> <h1 id="ease-of-writing-vs-ease-of-reading">Ease of Writing vs ease of Reading</h1> <p>When you implement a Hierarchy ID, you are making it more complex to <em>write</em> data; Whenever you add a node in the hierarchy you now have to set it’s Hierarchy ID. If your tree is mutable, you also need to handle updating the Hierarchy IDs of all children whenever nodes are moved - something that can take considerable time and capacity if a high-level node is moved. Similarly, you may need to write code to maintain a list of “allowed hierarchy IDs” per user. In other words, Hierarchy IDs adds extra complexity to your system.<br /> On the other hand, once Hierarchy IDs are in place, your data filtering/security code becomes much easier to write and your database queries will be much more performant.</p> <p>Whether Hierarchy IDs are right for a given solution will, as always, depend on the needs of that system. Some of the key indicators that you may need it are;</p> <ul> <li>Deep hierarchies with access rights determined at multiple levels</li> <li>Large data sets in a hierarchy</li> <li>Self-referential hierarchies with access rights set at arbitrary levels (think pretty much any organisational hierarchy with scope-of-control security)</li> </ul> <h1 id="hierarchical-configuration">Hierarchical Configuration</h1> <p>It is a common requirement to have Hierarchical Configuration where a certain setting is different for a certain part of the tree. For example, you may have some settings that only apply to a particular Reseller, Customer or even Branch etc.</p> <p>If you are already implementing Hierarchy IDs in the form of a delimited string, you could have a simple Configuration table that has the Key, the Value and the Hierarchy ID it applies to. When you want to find the value for a particular Hierarchy ID for a particular node, you can recursively search for a configuration setting that matches the node’s Hierarchy ID, or it’s parent or the grand parent etc, all the way up to the root. This is obviously not very efficient to query so you would need to cache it (or keep the whole thing in memory if possible), but it makes it very easy to model and extend.</p> <p>What you really want is something like (pseudo code)</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">Value</span> <span class="k">from</span> <span class="n">Config</span> <span class="k">WHERE</span>
<span class="n">Config</span><span class="p">.</span><span class="n">HierarchyID</span> <span class="o">=</span> <span class="k">SUBSTRING</span><span class="p">(</span><span class="n">node_hierarchy_id</span><span class="p">,</span> <span class="k">LENGTH</span><span class="p">(</span><span class="n">Config</span><span class="p">.</span><span class="n">HierarchyID</span><span class="p">))</span>
</code></pre></div></div> <p>You may well be able to write a SQL statement something like that, though it will definitely use a table scan - so still cache it.</p> <p>In the case of document database with an array of Ancestor IDs, you’d need to ensure that the Ancestor ID array on the node is sorted by descent level so that you can look for configuration values in the right order (by walking up the tree).</p> </div> <div id="disqus_thread"></div> <script> var disqus_config = function () { this.page.url = 'https://www.lytzen.name/2018/06/27/hierarchyid-for-fun-and-performance.html'; this.page.identifier = '/2018/06/27/hierarchyid-for-fun-and-performance.html'; }; (function() { var d = document, s = d.createElement('script'); s.src = 'https://flytzen.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> <a class="u-url" href="/2018/06/27/hierarchyid-for-fun-and-performance.html" hidden></a> </div> </article> </main> <footer class="footer"> <div class="wrapper"> <div class="social-links"> <a href="https://github.com/flytzen" target="_blank"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon"> <path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z" /> </svg> </a> <a href="https://www.linkedin.com/in/flytzen/" target="_blank"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon"> <path d="M21,21H17V14.25C17,13.19 15.81,12.31 14.75,12.31C13.69,12.31 13,13.19 13,14.25V21H9V9H13V11C13.66,9.93 15.36,9.24 16.5,9.24C19,9.24 21,11.28 21,13.75V21M7,21H3V9H7V21M5,3A2,2 0 0,1 7,5A2,2 0 0,1 5,7A2,2 0 0,1 3,5A2,2 0 0,1 5,3Z" /> </svg> </a> <a href="https://twitter.com/flytzen" target="_blank"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon"> <path d="M22.46,6C21.69,6.35 20.86,6.58 20,6.69C20.88,6.16 21.56,5.32 21.88,4.31C21.05,4.81 20.13,5.16 19.16,5.36C18.37,4.5 17.26,4 16,4C13.65,4 11.73,5.92 11.73,8.29C11.73,8.63 11.77,8.96 11.84,9.27C8.28,9.09 5.11,7.38 3,4.79C2.63,5.42 2.42,6.16 2.42,6.94C2.42,8.43 3.17,9.75 4.33,10.5C3.62,10.5 2.96,10.3 2.38,10C2.38,10 2.38,10 2.38,10.03C2.38,12.11 3.86,13.85 5.82,14.24C5.46,14.34 5.08,14.39 4.69,14.39C4.42,14.39 4.15,14.36 3.89,14.31C4.43,16 6,17.26 7.89,17.29C6.43,18.45 4.58,19.13 2.56,19.13C2.22,19.13 1.88,19.11 1.54,19.07C3.44,20.29 5.7,21 8.12,21C16,21 20.33,14.46 20.33,8.79C20.33,8.6 20.33,8.42 20.32,8.23C21.16,7.63 21.88,6.87 22.46,6Z" /> </svg> </a> </div> <div class="copyright"> &copy; Frans Lytzen 2018 </div> </div> </footer> </body> </html>
