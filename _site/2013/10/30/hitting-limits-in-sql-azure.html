<!DOCTYPE html> <html lang="en"> <head> <title>Frans' Randomness - Hitting the limits in SQL Azure</title> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="format-detection" content="telephone=no" /> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="/assets/main.css?v=20180627"> <link type="application/atom+xml" rel="alternate" href="https://www.lytzen.name/feed.xml" title="Frans' Randomness" /> <meta name="description" content="We use SQL Azure for most of our systems. For the most part, it “just works” and it is dead easy to get set up and start using. The main challenge facing most people is the need to handle retries, which is far from simple – but if you use..." /> </head> <body> <header class="header" role="banner"> <div class="wrapper"> <a class="header__title h3" rel="author" href="/">Frans&#39; Randomness</a> <nav class="header__nav"> <a class="header__nav-link" href="/talks">Talks</a> <a class="header__nav-link" href="/blog">Blog</a> </nav> </div> </header> <main class="page-content" aria-label="Content"> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post__header"> <div class="wrapper"> <h1 class="post__title" itemprop="name headline">Hitting the limits in SQL Azure</h1> <div class="post__meta"> <div class="post__author-time"> <span class="post__author" itemprop="author" itemscope itemtype="http://schema.org/Person"> <span itemprop="name">Author <strong>Frans Lytzen</strong></span> </span> <time class="post__date-time dt-published" datetime="2013-10-30T13:34:00+00:00" itemprop="datePublished"> <div class="date-time icon__item"> <svg class="icon__gfx" style="width:24px;height:24px" viewBox="0 0 24 24"> <path d="M19,19H5V8H19M16,1V3H8V1H6V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3H18V1" /> </svg> <span class="icon__txt">30 Oct 2013</span> </div> </time> </div> <div class="tags icon__item"> <svg class="icon__gfx" style="width:24px;height:24px" viewBox="0 0 24 24"> <path d="M5.5,9A1.5,1.5 0 0,0 7,7.5A1.5,1.5 0 0,0 5.5,6A1.5,1.5 0 0,0 4,7.5A1.5,1.5 0 0,0 5.5,9M17.41,11.58C17.77,11.94 18,12.44 18,13C18,13.55 17.78,14.05 17.41,14.41L12.41,19.41C12.05,19.77 11.55,20 11,20C10.45,20 9.95,19.78 9.58,19.41L2.59,12.42C2.22,12.05 2,11.55 2,11V6C2,4.89 2.89,4 4,4H9C9.55,4 10.05,4.22 10.41,4.58L17.41,11.58M13.54,5.71L14.54,4.71L21.41,11.58C21.78,11.94 22,12.45 22,13C22,13.55 21.78,14.05 21.42,14.41L16.04,19.79L15.04,18.79L20.75,13L13.54,5.71Z" /> </svg> <a href="/tags/#Azure" class="icon__txt tag">Azure</a> <a href="/tags/#SQL" class="icon__txt tag">SQL</a> </div> </div> </div> </header> <div class="wrapper"> <div class="post__content e-content" itemprop="articleBody"> <p>We use SQL Azure for most of our systems. For the most part, it “just works” and it is dead easy to get set up and start using. The main challenge facing most people is the need to handle retries, which is far from simple – but if you use Entity Framework then version 6 has you covered (which some caveats).</p><p>There are, however, situations where you can push SQL Azure too hard and you will have problems. In this post I will relay some of our experiences and how we went about resolving them. Once you know what you are looking for it isn’t terribly hard – but until then you will likely be tearing your hair out.</p><h2>Understanding SQL Azure limits</h2><p>At the time of this writing SQL Azure does not <em>enforce</em> limits on how hard you can hit the SQL Server – if there is capacity then you will be okay, but if the server happens to be busy then you will start seeing problems. This makes this very hard to test and plan for. However, rumour has it that Microsoft are thinking about enforcing some limits – which is actually a good thing as it will allow you to test things.</p><p>In the documentation for SQL Azure you will be told that when you are being throttled you will see a specific exception telling you this. I have never seen one of those exceptions, but I have seen plenty of timeouts. So, important point; just because you are not seeing “throttled” exceptions doesn’t mean that you are not, well, being throttled. It just means that the throttling is happening at a deeper layer and the SQL server isn’t able to bubble up the exception to your application.</p><p>The key metric you are probably used to looking at when working with SQL is how much memory and CPU you are consuming on the SQL Server. Sure enough, they are important to keep under control, but the primary bottleneck in SQL Azure right now is I/O and specifically <em>writing</em> to disk. In other words, the metrics you really want to look at are the <em>reads</em> and the <em>writes</em>. For the purpose of that discussion, the important term is IOPS – I/O Operations Per Second. In terms of SQL, one IOPS is one <em>page</em> from SQL being read or written. So, if your operation causes 100 write IOPS then it means that 100 8kb pages were written to disk. Remember that one page may have multiple records on it.</p><p>One way to reduce writes can be to have fewer indexes, which sounds counter intuitive; The idea is that you make writes cheaper as they are the primary bottleneck, in return for making reads more expensive, as reads are less of a bottleneck. What you also need to understand, however, is that some <em>read</em> queries actually write to the disk as well – more about this later. </p><p>Do note that Microsoft are rumoured to be be doing something about the I/O limitations at some point in the future, which may render this post irrelevant.</p><p>At the moment there are no official limits on how much you can hit SQL Azure, but if you try to keep your application under “several hundred” IOPS of either kind then you are probably ok.</p><h2>Our story</h2><p>We were very intermittently seeing problems with one of our bigger applications. Once in a while for 20 minutes or so the database would slow to a crawl and we would start seeing SQL Timeout exceptions being thrown by the dozen every minute. We could not figure out what was going and was looking at monitoring the network layer to see if there was a network issue and various other ideas. We spoke with Azure support who were nice and friendly but didn’t really move us very much forward. The fact that we weren’t seeing any of those famous “throttling” exceptions combined with the fact that we knew we weren’t really hitting the database all that hard lead us to believe that something in the Azure infrastructure was failing. Whether it was the network or SQL Azure or what – but we couldn’t see how it could be our fault.</p><p>Eventually we got to speak to a highly skilled SQL Azure Engineer who explained about the bottlenecks in SQL Azure and was able to show from the back-end telemetry that we were absolutely hammering the poor database, frequently exceeding 1,600 write IOPS (which is a lot in case you wonder). We were also pretty high on reads and CPU but, as was explained to us, it was the writes that was causing the real problem and was basically choking the server, leading to the timeouts. </p><p>We reviewed our audit logs and, well, we aren’t actually writing that many records and certainly not nearly enough to account for this many writes to the database so puzzlement ensued. The next step was to install some software on a worker role to get some telemetry about what was really going on (see below for more details).</p><p>It turned out that there was a specific <em>read</em> query that users run quite a lot that, because of the way it was written, was causing a very large temp table to be created with hundreds of thousands of records in it. Every time the query ran, it would cause 1.3 million reads and 3,400 writes. Just running it once is enough to spike the write IOPS way over the top and under certain circumstances a user was able to run it tens of times in quick succession.</p><p>The culprit turned out to be a read query that looked at a table with about 300,000 records (so not really a lot). We use Entity Framework for data access and most of the time it is spot on, but some times it can do something rather less than optimal.</p><p>The original code looked something like this:</p><pre class="brush: c-sharp; toolbar: false">from c in Cases.OfType&lt;EmploymentCase&gt;<br />let application = c.Applications.FirstOrDefault()<br /></pre><p>The modified code looked something like this:</p><pre class="brush: c-sharp; toolbar: false">from a in Applications<br />where a.Case is EmploymentCase<br /></pre><p>In terms of the difference between the two:</p><table cellspacing="0" cellpadding="2" border="1"><tbody><tr> <td valign="top">&nbsp;</td> <td valign="top">CPU</td> <td valign="top">Reads</td> <td valign="top">Writes</td></tr><tr> <td valign="top">Old</td> <td valign="top" align="right">2,280</td><td valign="top" align="right">1,319,925</td> <td valign="top" align="right">3,422</td> </tr><tr> <td valign="top">New</td> <td valign="top" align="right">16</td> <td valign="top" align="right">7,026</td> <td valign="top" align="right">0</td> </tr></tbody></table><h2>How you can detect and fix this</h2><p>This is one of those where the tooling provided by Azure is less than optimal; you can’t run SQL Profiler against your Azure SQL database – and even if you could it would probably be hard to see what was going on in a live environment.</p><p>In your local development environment you probably have the database locally on a nice, fast SSD so you probably won’t notice problem queries, even if you test on a copy of the live database. Even up in Azure, most of the time you will be fine; the bad old query above would return in about 2 seconds in most cases so didn’t raise any major concerns.</p><p>The simplest thing you can do is to fire up SQL Profiler and work through your application locally and try to monitor for queries that cause a lot of reads or writes – but it really is looking for a needle in a haystack. Still, I recommend you do it – if for no other reason than to spot excessive database chatter. Also consider using <a href="http://getglimpse.com/">Glimpse</a> or <a href="http://miniprofiler.com/">MiniProfiler</a> to get information in the UI about excessive or slow database calls.</p><p>Really, though, you want to know how hard you are hitting your production database and which queries are the culprit. There is information in the database itself about queries and the cost of them, but it is hard to use this information in it’s raw form, primarily because the cost of a query is recorded as all-time cost since SQL first saw that particular query. There <a href="http://social.technet.microsoft.com/wiki/contents/articles/17987.cloud-service-fundamentals.aspx">is a tool available on MSDN</a> which can run on a worker role, which will read the performance every few minutes and calculate the deltas so you can actually use the information. We received our copy direct from Microsoft, but I believe the version on MSDN is the same or similar, though I have not verified this. Suffice to say, once that tool had run for 30 minutes on the live database we had found the problem and had fixed it less than an hour later. Highly recommended!</p><h2>In conclusion</h2><p>You and only you own the performance and availability of your application. With all the nice wrapper layers we use in the code and our nice, fast development machines it is very easy to release something to production that will sometimes overload SQL Azure and bring your application down. Own the problem and monitor your systems. </p><p>I do wish that Microsoft would make some of this SQL Telemetry available in the management portal; Even if all they do is show us the SQL CPU and IOPS usage, we can at least tell if there is a problem and take appropriate action.</p> </div> <div id="disqus_thread"></div> <script> var disqus_config = function () { this.page.url = 'https://www.lytzen.name/2013/10/30/hitting-limits-in-sql-azure.html'; this.page.identifier = '/2013/10/30/hitting-limits-in-sql-azure.html'; }; (function() { var d = document, s = d.createElement('script'); s.src = 'https://flytzen.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> <a class="u-url" href="/2013/10/30/hitting-limits-in-sql-azure.html" hidden></a> </div> </article> </main> <footer class="footer"> <div class="wrapper"> <div class="social-links"> <a href="https://github.com/flytzen" target="_blank" alt="GitHub"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon"> <path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z" /> </svg> </a> <a href="https://www.linkedin.com/in/flytzen/" target="_blank" alt="LinkedIn"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon"> <path d="M21,21H17V14.25C17,13.19 15.81,12.31 14.75,12.31C13.69,12.31 13,13.19 13,14.25V21H9V9H13V11C13.66,9.93 15.36,9.24 16.5,9.24C19,9.24 21,11.28 21,13.75V21M7,21H3V9H7V21M5,3A2,2 0 0,1 7,5A2,2 0 0,1 5,7A2,2 0 0,1 3,5A2,2 0 0,1 5,3Z" /> </svg> </a> <a href="https://twitter.com/flytzen" target="_blank"> <svg style="width:24px;height:24px" viewBox="0 0 24 24" class="social-icon" alt="Twitter"> <path d="M22.46,6C21.69,6.35 20.86,6.58 20,6.69C20.88,6.16 21.56,5.32 21.88,4.31C21.05,4.81 20.13,5.16 19.16,5.36C18.37,4.5 17.26,4 16,4C13.65,4 11.73,5.92 11.73,8.29C11.73,8.63 11.77,8.96 11.84,9.27C8.28,9.09 5.11,7.38 3,4.79C2.63,5.42 2.42,6.16 2.42,6.94C2.42,8.43 3.17,9.75 4.33,10.5C3.62,10.5 2.96,10.3 2.38,10C2.38,10 2.38,10 2.38,10.03C2.38,12.11 3.86,13.85 5.82,14.24C5.46,14.34 5.08,14.39 4.69,14.39C4.42,14.39 4.15,14.36 3.89,14.31C4.43,16 6,17.26 7.89,17.29C6.43,18.45 4.58,19.13 2.56,19.13C2.22,19.13 1.88,19.11 1.54,19.07C3.44,20.29 5.7,21 8.12,21C16,21 20.33,14.46 20.33,8.79C20.33,8.6 20.33,8.42 20.32,8.23C21.16,7.63 21.88,6.87 22.46,6Z" /> </svg> </a> <a rel="me" href="https://hachyderm.io/@flytzen" target="_blank"> <svg style="width:24px;height:24px" fill="currentColor" viewBox="0 0 24 24" class="social-icon" alt="Mastodon"> <path d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a3.614 3.614 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522c0-.859.22-1.541.66-2.046.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764.442.505.661 1.187.661 2.046v4.203z"/> </svg> </a> </div> <div class="copyright"> &copy; Frans Lytzen 2022 </div> </div> </footer> </body> </html>
